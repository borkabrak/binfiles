#!/usr/bin/env bash
#
#   Prepare a branch so that a Pull Request into trunk, our QA branch, can be
#   made without further git-fu on the command line
#
# TODO:
#
#   * Add appropriate error-checking
#
#   * quote branch names
#
#   * You'll probably have to *replace* the 'bugfix/hotfix/feature' part with
#   'qa', instead of prepending it.
#
#   * thoroughly test in the real environment
#
#   * refactor
#       - Consider whether get-base-branch could be rewritten more simply using
#       'git merge-base', possibly with the --fork-point option.
#
#   * test again

## CONFIG ##
# The leading/trailing spaces matter here (find '=~')
public_branches=" master release trunk "

## FUNCTIONS ##
# NOTE: bash functions `return` integers which are to be used as status codes.
# To "return" a value, output it and capture that when calling 

function branch-exists() { 
    local branch=$1
    [[ -n $(git rev-parse -q --verify $branch) ]] && return 0 || return 1; 
}

function is-public() { 
    local branch=$1
    [[ $public_branches =~ " $branch " ]] && return 0 || return 1; 
}

function show-usage() {
cat <<END

USAGE: $(basename $0) [<branch>]

    <branch>: Branch to rebase.  It must exist and not be a public branch (like master, release, or trunk).

END
}

function get-branch() {
# return the branch name to work with:
#
#   * If we have an argument, use that
#
#   * Otherwise, assume the current branch

    local branch
    [[ $# > 0 ]] && branch=$1 || branch=$(git symbolic-ref --short HEAD)
    echo $branch
}

function get_base_branch() {
# Given a particular branch, determine which of the public branches it's
# closest to.  That will then be used as the branch it was created on.  This an
# ASSUMPTION, but seems safe enough.

# git may have some shortcuts better than this for us
    local branch=$1
    local shortest=9999
    local distance
    local base_branch
    for public_branch in $public_branches; do
        current_distance=$(git log --oneline $public_branch..$branch | wc -l)
        if [ $current_distance -lt $shortest ]; then
            shortest=$current_distance
            base_branch=$public_branch
        fi
    done
    echo $base_branch

}

## BEGIN MAIN SCRIPT EXECUTION ##

# Are we in a git repo?
if ! git rev-parse --is-inside-work-tree 2>&1 >/dev/null; then
    show-usage
    echo "Try running this from within a git repository."
    exit
fi

# Do we have a valid branch to work with?
branch=$(get-branch $@)
if ! branch-exists $branch || is-public $branch; then
    echo "'$branch' is either public or non-existent."
    show-usage
    exit
fi

# What public branch did we fork from?
base_branch=$(get_base_branch $branch)

# Everything looks good.  Create the QA branch as a copy of the given work
# branch.
qa_branch="qa/$branch"
echo "Creating QA branch '$qa_branch' to merge into trunk.."
git checkout -b "$qa_branch" trunk

# Display the commits we think comprise the branch
echo -e "\n---------\n"
git log --oneline "$base_branch".."$branch"
echo -e "\n---------\n"

# Ask the user if everything looks good
echo -ne "\n\nINFORMATION REQUIRED:\n\tAre these EXACTLY the commits in your branch?\n> "
read response

if [[ $response =~ "^[nN]" ]]; then
    echo "Aborting.."
    exit
fi

# Still here? Proceed with building the new branch out of the commits of the old
echo "Populating $qa_branch with the commits from $branch.."

git cherry-pick "$base_branch".."$branch"

# Confirm everything went well, and push?
# git push

echo "Done.  Create the pull request to merge $qa_branch into trunk."
